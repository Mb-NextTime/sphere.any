## Задание:
### Реализовать аналог std::any без RTTI
- Основная идея – type safe аналог void*. Т.е. при попытке получить из std::any не то, что в него положили - будет ошибка. При этом заранее типы не оговариваются (как, например, в variant)
- В дополнение требуются any_cast (перегрузка с исключением и без), make_any
- Правильно удалить подлежащий объект при вызове reset() или деструктора

## Реализация:
Основная идея реализации - храним данные в _void*_ (_M_storage), а также поддерживаем указатель на функцию шаблонной структуры-менеджера (_M_manager).  
Менеджер отвечает за все копирования, освобождение памяти и тд.  


## Демонстрационная программа:
Вводится **n** _маркеров типа_ и соответствующих значения (**n** также задается через стандартный поток ввода).  
> _Маркеры типов_:  
> - i - _int_
> - f - _float_
> - d - _double_
> - s - _string_
> - t - _tag_,  
> 
> где _tag_ - структура состоящая из 2 полей: id (_int_) и description (_string_).  

Введенные значения последовательно записываются в инстанс _any_.   
Затем вводиться последний маркер, к которому преобразовывается текущее значение _any_ и, в случае успеха, выводится в стандартный поток вывода.

## Сборка:
Для сборки:
> $ make  
  
Запустить тесты:
> $ make test
  
Очистить исполняемые и временные файлы:
> $ make clean